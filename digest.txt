Directory structure:
└── src/
    ├── index.ts
    └── core/
        ├── bot.ts
        ├── decorators.ts
        ├── manager.ts
        ├── types.ts
        └── utils.ts

================================================
File: index.ts
================================================
import * as Manager from './core/manager';
import * as Utils from './core/utils';
import * as Types from './core/types';
import * as Bot from './core/bot';

export * from './core/manager';
export * from './core/types';
export * from './core/utils';
export * from './core/bot';

export default {
	...Manager,
	...Utils,
	...Types,
	...Bot,
};



================================================
File: core/bot.ts
================================================
import { Card, CardColor, cardColors, Player, PlayedCard, Callings, AllPossibleCalls } from './types';
import { validateCalling, getCardValue, mulberry32, canBeatCard, canPlayCard } from './utils';

export class BotAI {
	static decideBid(player: Player): CardColor | 'pass' {
		const colorCounts: Record<CardColor, number> = { hearts: 0, diamonds: 0, clubs: 0, spades: 0 };
		const colorValues: Record<CardColor, number> = { hearts: 0, diamonds: 0, clubs: 0, spades: 0 };

		for (const card of player.cards) {
			colorCounts[card.color]++;
			colorValues[card.color] += getCardValue(card, card.color);
		}

		let bestColor: CardColor | null = null;
		let bestScore = 0;

		for (const color of cardColors) {
			const score = colorCounts[color] * 2 + colorValues[color] * 0.1;
			if (score > bestScore) {
				bestScore = score;
				bestColor = color;
			}
		}

		const minCardsForBid = 3;
		const minScoreForBid = 6;

		if (bestColor && colorCounts[bestColor] >= minCardsForBid && bestScore >= minScoreForBid) {
			return bestColor;
		}

		if (player.isDealer) {
			const rng = mulberry32(Date.now());
			return bestColor || cardColors[Math.floor(rng() * cardColors.length)]!;
		}

		return 'pass';
	}

	static decideCalling(player: Player, adut: CardColor): Card[] {
		const allPossibleCalls = this.findAllPossibleCalls(player.cards, adut);

		if (allPossibleCalls.length === 0) return [];

		allPossibleCalls.sort((a, b) => b.calling.type - a.calling.type);
		return allPossibleCalls[0]!.cards;
	}

	static decideCardToPlay(player: Player, currentTrick: PlayedCard[], adut: CardColor): Card {
		const allPlayerCards = [...player.cards, ...player.talon];

		const legalCards = allPlayerCards.filter((card) => canPlayCard(card, currentTrick, adut, allPlayerCards));
		if (legalCards.length === 0) throw new Error('No legal cards to play?');
		else if (legalCards.length === 1) return legalCards[0]!;

		// Leading - if no cards played, choose best card.
		if (currentTrick.length === 0) return this.chooseBestLeadingCard(legalCards, adut);
		// Following - try to win or play strategically.
		else return this.chooseBestFollowingCard(legalCards, currentTrick, adut);
	}

	static findAllPossibleCalls(cards: Card[], adut: CardColor): AllPossibleCalls[] {
		const results: { cards: Card[], calling: { type: Callings } }[] = [];

		for (let i = 1; i < (1 << cards.length); i++) {
			const subset: Card[] = [];
			for (let j = 0; j < cards.length; j++) {
				if (i & (1 << j)) {
					subset.push(cards[j]!);
				}
			}

			const calling = validateCalling(subset, adut);
			if (calling) results.push({ cards: subset, calling });
		}

		return results;
	}

	static chooseBestLeadingCard(cards: Card[], adut: CardColor): Card {
		// Prefer trump cards, then high-value cards.
		const trumpCards = cards.filter((c) => c.color === adut);
		if (trumpCards.length > 0) {
			return trumpCards.reduce((best, current) =>
				getCardValue(current, adut) > getCardValue(best, adut) ? current : best,
			);
		}

		// Otherwise play highest value card.
		return cards.reduce((best, current) => getCardValue(current, adut) > getCardValue(best, adut) ? current : best);
	}

	static chooseBestFollowingCard(cards: Card[], currentTrick: PlayedCard[], adut: CardColor): Card {
		const winningCards = cards.filter((card) => {
			return currentTrick.every((playedCard) => canBeatCard(card, playedCard, adut));
		});

		if (winningCards.length > 0) return winningCards.reduce((best, current) => getCardValue(current, adut) < getCardValue(best, adut) ? current : best);
		return cards.reduce((best, current) => getCardValue(current, adut) < getCardValue(best, adut) ? current : best);
	}
}



================================================
File: core/decorators.ts
================================================
import { Belote } from './manager';
import EventEmitter from 'events';

export function withErrorHandling(_: unknown, propertyName: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor {
	const originalMethod = descriptor.value;

	descriptor.value = function (this: EventEmitter, ...args: unknown[]): unknown {
		try {
			const result = originalMethod.apply(this, args);

			if (result && typeof result === 'object' && result !== null && 'catch' in result && typeof result.catch === 'function') {
				return (result as Promise<unknown>).catch((error: unknown) => {
					if (this.emit && typeof this.emit === 'function') this.emit('error', error instanceof Error ? error : new Error(`${String(propertyName)}: ${String(error)}`));
					throw error;
				});
			}

			return result;
		} catch (error: unknown) {
			if (this.emit && typeof this.emit === 'function') this.emit('error', error instanceof Error ? error : new Error(`${String(propertyName)}: ${String(error)}`));
			throw error;
		}
	};

	return descriptor;
}

export function withErrorHandlingClass<T extends typeof Belote>(constructor: T): T {
	const prototype = constructor.prototype;
	const methodNames = Object.getOwnPropertyNames(prototype);

	methodNames.forEach((name: string) => {
		if (name === 'constructor') return;

		const descriptor = Object.getOwnPropertyDescriptor(prototype, name);
		if (descriptor && typeof descriptor.value === 'function' && !name.startsWith('_')) {
			withErrorHandling(prototype, name, descriptor);
			Object.defineProperty(prototype, name, descriptor);
		}
	});

	return constructor;
}



================================================
File: core/manager.ts
================================================
import { GameState, GamePhase, CardColor, Player, Card, GameOptions, Callings, Trick, CallingsCall, cardColors, PlayedCard, BeloteEvents, AllowedPlayerKeys } from './types';
import { createDeck, shuffleCards, validateCalling, canPlayCard, findLegalCard, getHighestCall, compareCallStrength, canBeatCard, getCardValue } from './utils';
import { withErrorHandlingClass } from './decorators';
import { EventEmitter } from 'events';
import { BotAI } from './bot';

@withErrorHandlingClass
export class Belote extends EventEmitter {
	private timeoutId: NodeJS.Timeout | null = null;
	public readonly options: GameOptions;
	public readonly gameState: GameState;

	constructor (init?: Partial<GameOptions>) {
		super();

		this.options = Object.assign({
			endValue: 501,
			moveTimeSec: 30,
			botDelayMs: 500,
			pauseBetweenRoundsMs: 1000,
		}, init);

		this.gameState = {
			players: [],
			team1: { id: 1, name: 'Team 1', score: [], tricksHistory: [] },
			team2: { id: 2, name: 'Team 2', score: [], tricksHistory: [] },
			deck: createDeck(),
			round: 0,
			adut: null,
			bids: [],
			calls: [],
			gamePhase: GamePhase.Waiting,
			currentTrick: null,
			currentPlayerIndex: 0,
			currentPlayerTimeLeft: this.options.moveTimeSec,
			isGameOver: false,
		};
	}

	private createPlayer(playerName?: string, options?: Partial<Pick<Player, AllowedPlayerKeys | 'isReady' | 'isBot'>>): Player {
		if (this.gameState.players.length >= 4) throw new Error('Cannot add more than 4 players.');
		else if (options?.id && this.gameState.players.some((p) => p.id === options.id)) throw new Error(`Player with ID ${options.id} already exists.`);
		else if (options?.teamId && options.teamId !== 1 && options.teamId !== 2) throw new Error(`Invalid team ID: ${options.teamId}. Must be 1 or 2.`);
		else if (options?.teamId && this.gameState.players.filter((p) => p.teamId === options.teamId).length >= 2) throw new Error(`Team ${options.teamId} is already full.`);

		const idPrefix = options?.isBot ? 'bot' : 'player';
		const defaultName = options?.isBot ? 'Bot' : 'Player';
		const playerIndex = this.gameState.players.length + 1;

		const newPlayer: Player = {
			id: options?.id || `${idPrefix}-${playerIndex}`,
			name: playerName || `${defaultName} ${playerIndex}`,
			teamId: options?.teamId || (this.gameState.players.length % 2 === 0 ? 1 : 2),
			isReady: options?.isBot ? true : options?.isReady || false,
			isDealer: this.gameState.players.length === 0,
			isBot: options?.isBot || false,
			cards: [],
			talon: [],
		};

		this.gameState.players.push(newPlayer);
		this.emit('playerJoined', newPlayer);

		if (this.gameState.players.length === 4 && this.gameState.players.every((p) => p.isReady)) {
			this.emit('allPlayersReady');
		}

		return newPlayer;
	}

	public playerJoin(playerName?: string, options?: Partial<Pick<Player, AllowedPlayerKeys>>): Player {
		return this.createPlayer(playerName, options);
	}

	public playerLeave(playerId: string): void {
		const playerIndex = this.gameState.players.findIndex((p) => p.id === playerId);
		if (playerIndex === -1) throw new Error(`Player with ID ${playerId} does not exist.`);

		const [removedPlayer] = this.gameState.players.splice(playerIndex, 1);
		this.emit('playerLeft', removedPlayer!.id);

		if (this.gameState.players.length < 4) {
			this.clearTimer();
			this.emit('notEnoughPlayers');
		}
	}

	public addBot(botName?: string, options?: Partial<Pick<Player, AllowedPlayerKeys>>): Player {
		return this.createPlayer(botName, { ...options, isBot: true, isReady: true });
	}

	public removeBot(botId: string): void {
		this.playerLeave(botId);
	}

	public updatePlayer(playerId: string, updates: Partial<Player> | ((player: Player) => Partial<Player>)): void {
		const player = this.gameState.players.find((p) => p.id === playerId);
		if (!player) throw new Error(`Player with ID ${playerId} does not exist.`);

		if (typeof updates === 'function') Object.assign(player, updates(player));
		else Object.assign(player, updates);
	}

	public switchPlayerTeam(playerId: string, newTeamId: number): void {
		const player = this.gameState.players.find((p) => p.id === playerId);
		if (!player) throw new Error(`Player with ID ${playerId} does not exist.`);
		else if (newTeamId !== 1 && newTeamId !== 2) throw new Error(`Team ID ${newTeamId} does not exist.`);
		else if (player.teamId === newTeamId) throw new Error(`Player with ID ${playerId} is already in team ${newTeamId}.`);
		else if (this.gameState.players.filter((p) => p.teamId === newTeamId).length >= 2) throw new Error(`Team ${newTeamId} is already full.`);

		this.updatePlayer(playerId, { teamId: newTeamId });
		this.emit('playerSwitchedTeam', playerId, newTeamId);
	}

	public setPlayerReady(playerId: string, isReady: boolean): void {
		const player = this.gameState.players.find((p) => p.id === playerId);
		if (!player) throw new Error(`Player with ID ${playerId} does not exist.`);
		else if (player.isBot) return;

		this.updatePlayer(playerId, { isReady });
		this.emit('playerReadyChanged', playerId, isReady);

		if (this.gameState.players.length === 4 && this.gameState.players.every((p) => p.isReady)) {
			this.emit('allPlayersReady');
		}
	}

	private clearTimer(): void {
		if (this.timeoutId) {
			clearTimeout(this.timeoutId);
			this.timeoutId = null;
		}
	}

	private startTimer(durationSec: number, onTimeout: () => void, executor?: Player): void {
		this.clearTimer();
		this.gameState.currentPlayerTimeLeft = durationSec;

		const startTime = Date.now();
		const updateInterval = setInterval(() => {
			const elapsed = Math.floor((Date.now() - startTime) / 1000);
			this.gameState.currentPlayerTimeLeft = Math.max(0, durationSec - elapsed);
			this.emit('timerUpdate', this.gameState.currentPlayerTimeLeft, executor || null);

			if (this.gameState.currentPlayerTimeLeft <= 0) clearInterval(updateInterval);
		}, 1000);

		this.timeoutId = setTimeout(() => {
			clearInterval(updateInterval);
			onTimeout();
		}, durationSec * 1000);
	}

	private safeBotAction(action: () => void): void {
		if (this.options.botDelayMs <= 0) return action();

		setTimeout(() => {
			try {
				action();
			} catch (error) {
				this.emit('error', error instanceof Error ? error : new Error(`Bot error: ${error}`));
			}
		}, this.options.botDelayMs);
	}

	public startGame(): void {
		if (this.gameState.players.length < 4) throw new Error('Need 4 players to start');
		if (this.gameState.players.some((p) => !p.isReady)) throw new Error('All players must be ready');

		this.gameState.round = 0;
		this.gameState.isGameOver = false;
		this.gameState.team1.score = [];
		this.gameState.team2.score = [];
		this.gameState.team1.tricksHistory = [];
		this.gameState.team2.tricksHistory = [];

		this.emit('gameStarted', this.gameState);
		this.startNextRound();
	}

	public startNextRound(): void {
		if (this.gameState.isGameOver) return;

		this.gameState.round++;
		this.gameState.adut = null;
		this.gameState.bids = [];
		this.gameState.calls = [];
		this.gameState.currentTrick = null;

		for (const player of this.gameState.players) {
			player.cards = [];
			player.talon = [];
		}

		const currentDealerIndex = this.gameState.players.findIndex((p) => p.isDealer);
		for (const player of this.gameState.players) this.updatePlayer(player.id, { isDealer: false });

		const nextDealerIndex = (currentDealerIndex + 1) % 4;
		const nextDealer = this.gameState.players[nextDealerIndex];
		if (!nextDealer) throw new Error('No players available to be dealer.');

		this.updatePlayer(nextDealer.id, { isDealer: true });
		this.emit('roundStarted', this.gameState.round, this.gameState.players[nextDealerIndex]!);

		this.dealInitialCards();
	}

	private dealInitialCards(): void {
		this.gameState.gamePhase = GamePhase.Dealing;
		this.gameState.deck = shuffleCards(createDeck());

		for (let round = 0; round < 2; round++) {
			for (const player of this.gameState.players) {
				const threeCards = this.gameState.deck.splice(0, 3);
				player.cards.push(...threeCards);
			}
		}

		this.emit('initialCardsDealt', this.gameState.players.map((p) => ({
			playerId: p.id,
			cardCount: p.cards.length,
		})));

		this.startBidding();
	}

	public getCurrentPlayer(): Player {
		return this.gameState.players[this.gameState.currentPlayerIndex]!;
	}

	private startBidding(): void {
		this.gameState.gamePhase = GamePhase.Bidding;
		const dealerIndex = this.gameState.players.findIndex((p) => p.isDealer);
		this.gameState.currentPlayerIndex = (dealerIndex + 1) % 4;

		this.emit('biddingStarted', this.getCurrentPlayer());

		const currentPlayer = this.getCurrentPlayer();
		if (currentPlayer.isBot) {
			this.safeBotAction(() => {
				const botDecision = BotAI.decideBid(currentPlayer);
				this.bid(currentPlayer.id, botDecision);
			});
		} else {
			this.startTimer(this.options.moveTimeSec, () => {
				this.bid(this.getCurrentPlayer().id, 'pass');
			}, currentPlayer);
		}
	}

	public bid(playerId: string, call: CardColor | 'pass'): void {
		const player = this.gameState.players.find((p) => p.id === playerId);
		if (!player) throw new Error(`Player with ID ${playerId} does not exist.`);
		if (this.gameState.gamePhase !== GamePhase.Bidding) throw new Error('Not in bidding phase.');

		const currentPlayer = this.getCurrentPlayer();
		if (player.id !== currentPlayer.id) throw new Error(`It's not player ${playerId}'s turn.`);
		else if (call === 'pass' && player.isDealer) throw new Error('Dealer cannot pass during bidding.');

		this.clearTimer();

		this.gameState.bids.push({
			playerId: player.id,
			call: call === 'pass' ? null : call,
		});

		this.emit('bidMade', playerId, call);

		if (call !== 'pass') {
			this.gameState.adut = call;
			this.emit('adutChosen', call, playerId);
			this.dealTalon();
			return;
		}

		this.advanceBidding();
	}

	private advanceBidding(): void {
		this.gameState.currentPlayerIndex = (this.gameState.currentPlayerIndex + 1) % 4;

		const adutCalls = this.gameState.bids.filter((c) => 'call' in c && (c.call === null || typeof c.call === 'string'));

		if (adutCalls.length < 4) {
			this.emit('nextPlayerBid', this.getCurrentPlayer());

			const currentPlayer = this.getCurrentPlayer();
			if (currentPlayer.isBot) {
				this.safeBotAction(() => {
					const botDecision = BotAI.decideBid(currentPlayer);
					this.bid(currentPlayer.id, botDecision);
				});
			} else {
				this.startTimer(this.options.moveTimeSec, () => {
					const currentPlayer = this.getCurrentPlayer();
					const randomColor = cardColors[Math.floor(Math.random() * cardColors.length)]!;

					this.bid(currentPlayer.id, currentPlayer.isDealer ? randomColor : 'pass');
				}, currentPlayer);
			}
		}
	}

	private dealTalon(): void {
		for (const player of this.gameState.players) {
			const twoCards = this.gameState.deck.splice(0, 2);
			player.talon.push(...twoCards);
		}

		this.emit('talonDealt', this.gameState.players.map((p) => ({
			playerId: p.id,
			talon: p.talon,
		})));

		this.startCallingPhase();
	}

	private startCallingPhase(): void {
		this.gameState.gamePhase = GamePhase.Calling;
		this.emit('callingPhaseStarted');

		for (const player of this.gameState.players) {
			if (player.isBot) {
				this.safeBotAction(() => {
					const hasAlreadyCalled = this.gameState.calls.some((call) => call.playerId === player.id);
					if (!hasAlreadyCalled && this.gameState.adut) {
						const allPlayerCards = [...player.cards, ...player.talon];
						const botDecision = BotAI.decideCalling(
							{ ...player, cards: allPlayerCards },
							this.gameState.adut,
						);

						this.makeCall(player.id, botDecision);
					}
				});
			}
		}

		const makeCalls = () => {
			for (const player of this.gameState.players) {
				const hasAlreadyCalled = this.gameState.calls.some((call) => call.playerId === player.id);
				if (!hasAlreadyCalled && !this.gameState.isGameOver) this.makeCall(player.id, []);
			}
		};

		const allBots = this.gameState.players.filter((p) => p.isBot).length === this.gameState.players.length;
		if (allBots) makeCalls();
		else this.startTimer(this.options.moveTimeSec, makeCalls);
	}

	public makeCall(playerId: string, cards: Card[]): void {
		const player = this.gameState.players.find((p) => p.id === playerId);
		if (!player) throw new Error(`Player with ID ${playerId} does not exist.`);
		if (this.gameState.gamePhase !== GamePhase.Calling) throw new Error('Not in calling phase.');

		const hasAlreadyCalled = this.gameState.calls.some((call) => call.playerId === playerId);
		if (hasAlreadyCalled) throw new Error('Player has already made a call.');

		if (!this.gameState.adut) throw new Error('Adut must be chosen before making calls.');
		this.clearTimer();

		const callingResult = validateCalling(cards, this.gameState.adut);
		this.gameState.calls.push({
			playerId: player.id,
			call: callingResult?.type || Callings.None,
			cards: cards,
		});

		if (callingResult && callingResult.type === Callings.Belot) {
			const belotColor = cards[0]!.color;

			this.gameState.isGameOver = true;
			this.gameState.gamePhase = GamePhase.Finished;

			const playerTeam = player.teamId === 1 ? this.gameState.team1 : this.gameState.team2;
			const pointsNeeded = this.options.endValue - playerTeam.score.reduce((sum, score) => sum + score, 0);
			playerTeam.score.push(pointsNeeded);

			this.gameState.winnerTeam = playerTeam;

			this.emit('belotWin', playerId, belotColor);
			this.emit('gameEnded', this.gameState.winnerTeam, {
				team1: this.gameState.team1.score.reduce((sum, score) => sum + score, 0),
				team2: this.gameState.team2.score.reduce((sum, score) => sum + score, 0),
			}, true);

			return;
		}

		this.emit('callMade', playerId, cards, callingResult);

		if (this.gameState.calls.length === 4) {
			this.resolveCalls();
		}
	}

	private resolveCalls(): void {
		const team1Calls = this.gameState.calls.filter((call) => {
			const player = this.gameState.players.find((p) => p.id === call.playerId);
			return player?.teamId === 1;
		});

		const team2Calls = this.gameState.calls.filter((call) => {
			const player = this.gameState.players.find((p) => p.id === call.playerId);
			return player?.teamId === 2;
		});

		const team1HighestCall = getHighestCall(team1Calls);
		const team2HighestCall = getHighestCall(team2Calls);

		let winningCall: CallingsCall | null = null;

		if (!team1HighestCall && !team2HighestCall) winningCall = null;
		else if (!team1HighestCall) winningCall = team2HighestCall;
		else if (!team2HighestCall) winningCall = team1HighestCall;
		else {
			const comparison = compareCallStrength(team1HighestCall, team2HighestCall);
			if (comparison > 0) winningCall = team1HighestCall;
			else if (comparison < 0) winningCall = team2HighestCall;
			else {
				const adutCaller = this.gameState.bids.find((bid) => bid.call === this.gameState.adut)?.playerId;
				const adutCallerTeam = this.gameState.players.find((p) => p.id === adutCaller)?.teamId;

				if (adutCallerTeam === 1) winningCall = team1HighestCall;
				else winningCall = team2HighestCall;
			}
		}

		this.gameState.calls = winningCall ? [winningCall] : [];

		this.emit('callingPhaseEnded', winningCall);
		this.startPlayingPhase();
	}

	private startPlayingPhase(): void {
		this.gameState.gamePhase = GamePhase.Playing;
		this.gameState.currentPlayerIndex = 0;
		this.gameState.currentTrick = {
			cardsPlayed: [],
		};

		this.emit('playingPhaseStarted');
		this.emit('nextPlayerMove', this.getCurrentPlayer());

		const currentPlayer = this.getCurrentPlayer();
		if (currentPlayer.isBot) {
			this.safeBotAction(() => {
				if (this.gameState.adut) {
					const allPlayerCards = [...currentPlayer.cards, ...currentPlayer.talon];
					const botDecision = BotAI.decideCardToPlay(
						{ ...currentPlayer, cards: allPlayerCards },
						this.gameState.currentTrick?.cardsPlayed || [],
						this.gameState.adut,
					);

					this.playCard(currentPlayer.id, botDecision);
				}
			});
		} else {
			this.startTimer(this.options.moveTimeSec, () => {
				const player = this.getCurrentPlayer();
				if (player.cards.length > 0 && this.gameState.adut) {
					const legalCard = findLegalCard(
						this.gameState.currentTrick?.cardsPlayed || [],
						this.gameState.adut,
						player.cards,
					);

					if (legalCard) this.playCard(player.id, legalCard);
				}
			}, currentPlayer);
		}
	}

	public playCard(playerId: string, card: Card): void {
		const player = this.gameState.players.find((p) => p.id === playerId);
		if (!player) throw new Error(`Player with ID ${playerId} does not exist.`);
		if (this.gameState.gamePhase !== GamePhase.Playing) throw new Error('Not in playing phase.');

		const currentPlayer = this.getCurrentPlayer();
		if (player.id !== currentPlayer.id) throw new Error(`It's not player ${playerId}'s turn.`);

		const allPlayerCards = [...player.cards, ...player.talon];
		const cardIndex = allPlayerCards.findIndex((c) => c.color === card.color && c.type === card.type);
		if (cardIndex === -1) throw new Error('Card not found in player hand.');
		else if (!this.gameState.adut) throw new Error('Adut must be chosen before playing cards.');

		const currentTrick = this.gameState.currentTrick?.cardsPlayed || [];
		if (!canPlayCard(card, currentTrick, this.gameState.adut, allPlayerCards)) {
			console.error(`Player ${playerId} tried to play an illegal card!`, {
				card, currentTrick,
				adut: this.gameState.adut,
				allPlayerCards,
			});

			throw new Error('This card cannot be played according to Belote rules.');
		}

		this.clearTimer();

		const cardInHandIndex = player.cards.findIndex((c) => c.color === card.color && c.type === card.type);
		const cardInTalonIndex = player.talon.findIndex((c) => c.color === card.color && c.type === card.type);

		if (cardInHandIndex !== -1) player.cards.splice(cardInHandIndex, 1);
		else if (cardInTalonIndex !== -1) player.talon.splice(cardInTalonIndex, 1);

		this.gameState.currentTrick!.cardsPlayed.push({
			playerId: player.id,
			...card,
		});

		this.emit('cardPlayed', playerId, card);

		if (this.gameState.currentTrick!.cardsPlayed.length === 4) this.completeTrick();
		else {
			this.gameState.currentPlayerIndex = (this.gameState.currentPlayerIndex + 1) % 4;
			this.emit('nextPlayerMove', this.getCurrentPlayer());

			const nextPlayer = this.getCurrentPlayer();
			if (nextPlayer.isBot) {
				this.safeBotAction(() => {
					if (this.gameState.adut) {
						const allPlayerCards = [...nextPlayer.cards, ...nextPlayer.talon];
						const botDecision = BotAI.decideCardToPlay(
							{ ...nextPlayer, cards: allPlayerCards },
							this.gameState.currentTrick?.cardsPlayed || [],
							this.gameState.adut,
						);

						this.playCard(nextPlayer.id, botDecision);
					}
				});
			} else {
				this.startTimer(this.options.moveTimeSec, () => {
					const nextPlayer = this.getCurrentPlayer();
					if (nextPlayer.cards.length > 0 && this.gameState.adut) {
						const allPlayerCards = [...nextPlayer.cards, ...nextPlayer.talon];
						const legalCard = findLegalCard(
							this.gameState.currentTrick?.cardsPlayed || [],
							this.gameState.adut,
							allPlayerCards,
						);

						if (legalCard) this.playCard(nextPlayer.id, legalCard);
					}
				}, nextPlayer);
			}
		}
	}

	private completeTrick(): void {
		const winner = this.determineTrickWinner(this.gameState.currentTrick!);

		this.gameState.currentTrick!.winnerPlayerId = winner.playerId;
		this.gameState.currentTrick!.winningCard = { color: winner.color, type: winner.type };

		const winnerPlayer = this.gameState.players.find((p) => p.id === winner.playerId)!;
		const team = winnerPlayer.teamId === 1 ? this.gameState.team1 : this.gameState.team2;
		team.tricksHistory.push(this.gameState.currentTrick!);

		this.emit('trickCompleted', this.gameState.currentTrick!, winner.playerId);

		const allPlayersEmpty = this.gameState.players.every((p) => p.cards.length === 0 && p.talon.length === 0);

		if (allPlayersEmpty) this.completeRound();
		else {
			this.gameState.currentPlayerIndex = this.gameState.players.findIndex((p) => p.id === winner.playerId);
			this.gameState.currentTrick = { cardsPlayed: [] };

			this.emit('nextTrickStarted', this.getCurrentPlayer());

			const nextPlayer = this.getCurrentPlayer();
			if (nextPlayer.isBot) {
				this.safeBotAction(() => {
					if (this.gameState.adut) {
						const allPlayerCards = [...nextPlayer.cards, ...nextPlayer.talon];
						const botDecision = BotAI.decideCardToPlay(
							{ ...nextPlayer, cards: allPlayerCards },
							this.gameState.currentTrick?.cardsPlayed || [],
							this.gameState.adut,
						);

						this.playCard(nextPlayer.id, botDecision);
					}
				});
			} else {
				this.startTimer(this.options.moveTimeSec, () => {
					const nextPlayer = this.getCurrentPlayer();
					if ((nextPlayer.cards.length > 0 || nextPlayer.talon.length > 0) && this.gameState.adut) {
						const allPlayerCards = [...nextPlayer.cards, ...nextPlayer.talon];
						const legalCard = findLegalCard(
							this.gameState.currentTrick?.cardsPlayed || [],
							this.gameState.adut,
							allPlayerCards,
						);

						if (legalCard) this.playCard(nextPlayer.id, legalCard);
					}
				}, nextPlayer);
			}
		}
	}

	private determineTrickWinner(trick: Trick): PlayedCard {
		if (!this.gameState.adut) throw new Error('Adut must be set to determine trick winner.');

		let winningCard = trick.cardsPlayed[0]!;

		for (const playedCard of trick.cardsPlayed) {
			if (canBeatCard(playedCard, winningCard, this.gameState.adut)) {
				winningCard = playedCard;
			}
		}

		return winningCard;
	}

	private completeRound(): void {
		const roundScores = this.calculateRoundScores();

		this.gameState.team1.score.push(roundScores.team1);
		this.gameState.team2.score.push(roundScores.team2);

		const winningTeam = roundScores.team1 > roundScores.team2 ? this.gameState.team1 : this.gameState.team2;

		const adutCallerId = this.gameState.bids.find((bid) => bid.call === this.gameState.adut)?.playerId;
		const adutCallerTeam = this.gameState.players.find((p) => p.id === adutCallerId)?.teamId;

		let failedTeam = undefined;
		if (adutCallerTeam === 1 && roundScores.team1 === 0) failedTeam = this.gameState.team1;
		else if (adutCallerTeam === 2 && roundScores.team2 === 0) failedTeam = this.gameState.team2;

		this.emit('roundCompleted', this.gameState.round, roundScores, winningTeam, failedTeam);

		const team1Total = this.gameState.team1.score.reduce((a, b) => a + b, 0);
		const team2Total = this.gameState.team2.score.reduce((a, b) => a + b, 0);

		if (team1Total >= this.options.endValue || team2Total >= this.options.endValue) {
			this.gameState.isGameOver = true;
			this.gameState.gamePhase = GamePhase.Finished;
			this.gameState.winnerTeam = team1Total > team2Total ? this.gameState.team1 : this.gameState.team2;

			this.emit('gameEnded', this.gameState.winnerTeam, {
				team1: team1Total,
				team2: team2Total,
			});
		} else {
			if (this.options.pauseBetweenRoundsMs > 0) {
				this.clearTimer();
				this.timeoutId = setTimeout(() => this.startNextRound(), this.options.pauseBetweenRoundsMs);
			} else this.startNextRound();
		}
	}

	private calculateRoundScores(): { team1: number; team2: number } {
		let team1Points = 0;
		let team2Points = 0;

		for (const team of [this.gameState.team1, this.gameState.team2]) {
			let teamPoints = 0;

			for (const trick of team.tricksHistory) {
				for (const card of trick.cardsPlayed) {
					teamPoints += getCardValue(card, this.gameState.adut!);
				}
			}

			if (team.tricksHistory.length > 0) {
				const lastTrick = team.tricksHistory[team.tricksHistory.length - 1]!;
				const lastOverallTrick = this.getLastTrickOverall();

				if (lastOverallTrick && this.areTricksEqual(lastTrick, lastOverallTrick)) {
					teamPoints += 20;
				}
			}

			if (team.tricksHistory.length === 8) {
				teamPoints += 90;
			}

			if (team.id === 1) team1Points = teamPoints;
			else team2Points = teamPoints;
		}

		const callingPoints = this.gameState.calls.reduce((sum, call) => sum + call.call, 0);
		const totalGamePoints = 162 + callingPoints;
		const passingScore = Math.floor(totalGamePoints / 2) + 1;

		const adutCallerId = this.gameState.bids.find((bid) => bid.call === this.gameState.adut)?.playerId;
		const adutCallerTeam = this.gameState.players.find((p) => p.id === adutCallerId)?.teamId;

		switch (adutCallerTeam) {
			case 1: {
				// If team 1 called adut but doesn't have enough points, team 2 gets all points.
				if (team1Points >= passingScore) team1Points += callingPoints;
				else {
					team2Points = totalGamePoints;
					team1Points = 0;
				}

				break;
			}
			case 2: {
				// If team 2 called adut but doesn't have enough points, team 1 gets all points.
				if (team2Points >= passingScore) team2Points += callingPoints;
				else {
					team1Points = totalGamePoints;
					team2Points = 0;
				}

				break;
			}
			default: {
				// If no team called adut, both teams get the calling points.
				team1Points += callingPoints;
				team2Points += callingPoints;
				break;
			}
		}

		return { team1: team1Points, team2: team2Points };
	}

	private getLastTrickOverall(): Trick | null {
		const allTricks = [...this.gameState.team1.tricksHistory, ...this.gameState.team2.tricksHistory];
		return allTricks.length > 0 ? allTricks[allTricks.length - 1]! : null;
	}

	private areTricksEqual(trick1: Trick, trick2: Trick): boolean {
		for (let i = 0; i < trick1.cardsPlayed.length; i++) {
			const card1 = trick1.cardsPlayed[i]!;
			const card2 = trick2.cardsPlayed[i]!;

			if (card1.playerId !== card2.playerId || card1.color !== card2.color || card1.type !== card2.type) {
				return false;
			}
		}

		return true;
	}

	public getPlayerById(playerId: string): Player | null {
		return this.gameState.players.find((p) => p.id === playerId) || null;
	}

	public getPlayersByTeam(teamId: number): Player[] {
		return this.gameState.players.filter((p) => p.teamId === teamId);
	}

	public destroy(): void {
		this.clearTimer();
		this.removeAllListeners();
	}
}

// Declarations.
export interface Belote {
	on<K extends keyof BeloteEvents>(event: K, listener: BeloteEvents[K]): this;
	emit<K extends keyof BeloteEvents>(event: K, ...args: Parameters<BeloteEvents[K]>): boolean;
	off<K extends keyof BeloteEvents>(event: K, listener: BeloteEvents[K]): this;
	removeAllListeners<K extends keyof BeloteEvents>(event?: K): this;
	addListener<K extends keyof BeloteEvents>(event: K, listener: BeloteEvents[K]): this;
	once<K extends keyof BeloteEvents>(event: K, listener: BeloteEvents[K]): this;
}



================================================
File: core/types.ts
================================================
export const cardColors = ['hearts', 'diamonds', 'clubs', 'spades'] as const;
export type CardColor = typeof cardColors[number];

export const cardTypes = ['Ace', 'King', 'Queen', 'Jack', 'Ten', 'Nine', 'Eight', 'Seven'] as const;
export type CardType = typeof cardTypes[number];

export const cardTypeOrder: CardType[] = ['Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace'];

// Localized versions for Croatian Belot.
export const cardColorsLocal = ['herc', 'karo', 'tref', 'pik'] as const;
export type CardColorLocal = typeof cardColorsLocal[number];

export const cardTypesLocal = ['As', 'Kralj', 'Baba', 'Decko', 'Deset', 'Devet', 'Osam', 'Sedam'] as const;
export type CardTypeLocal = typeof cardTypesLocal[number];

export const cardTypeOrderLocal: CardTypeLocal[] = ['Sedam', 'Osam', 'Devet', 'Deset', 'Decko', 'Baba', 'Kralj', 'As'];

export enum CardPoints {
	Ace = 11,
	King = 4,
	Queen = 3,
	Jack = 2,
	Ten = 10,
	Nine = 0,
	Eight = 0,
	Seven = 0,
}

export enum CardPointsAdut {
	Ace = 11,
	King = 4,
	Queen = 3,
	Jack = 20,
	Ten = 10,
	Nine = 14,
	Eight = 0,
	Seven = 0,
}

export type Card = {
	color: CardColor;
	type: CardType;
}

export type PlayedCard = Card & {
	playerId: string;
}

export enum Callings {
	None = 0, // No call made.

	Belot = -1, // 8 cards of same color, instant win.
	Bela = 20, // King and Queen of adut.

	Jack4 = 200,
	Nine4 = 150,
	Ace4 = 100,
	King4 = 100,
	Queen4 = 100,
	Ten4 = 100,

	Sequence3 = 20,
	Sequence4 = 50,
	Sequence5 = 100,
	Sequence6 = 100,
	Sequence7 = 100,
}

export enum GamePhase {
	Waiting,
	Dealing,
	Bidding,
	Calling,
	Playing,
	Finished,
}

export type EndValue = 501 | 701 | 1001;
export type MoveTime = 10 | 20 | 30 | 40 | 50 | 60;

export type GameOptions = {
	endValue: EndValue;
	moveTimeSec: MoveTime;
	botDelayMs: number;
	pauseBetweenRoundsMs: number;
}

export type CallingResult = {
	type: Callings;
}

export type AllPossibleCalls = {
	cards: Card[];
	calling: CallingResult;
}

export type Trick = {
	cardsPlayed: PlayedCard[];
	winnerPlayerId?: string;
	winningCard?: Card;
}

export type Team = {
	id: number;
	name: string;
	score: number[];

	tricksHistory: Trick[];
}

export type AllowedPlayerKeys = 'color' | 'id' | 'teamId';
export type PartialPlayer = Pick<Player, AllowedPlayerKeys | 'name'>;

export type Player = {
	id: string;
	name: string;
	teamId: number;

	color?: string; // Color for UI representation, not game logic.

	isReady: boolean;
	isDealer: boolean;
	isBot: boolean;

	cards: Card[];
	talon: Card[];
}

export type AdutCall = {
	playerId: string;
	call: CardColor | null;
}

export type CallingsCall = {
	playerId: string;
	call: Callings;
	cards: Card[];
}

export type GameState = {
	players: Player[];
	team1: Team;
	team2: Team;

	deck: Card[];
	round: number;

	adut: CardColor | null;
	bids: AdutCall[];
	calls: CallingsCall[];

	gamePhase: GamePhase;
	currentTrick: Trick | null;

	currentPlayerIndex: number;
	currentPlayerTimeLeft: number; // Time left for the current player to make a move (in seconds).

	isGameOver: boolean;
	winnerTeam?: Team;
}

// Declarations.
export type BeloteEvents = {
	// General events.
	error: (error: Error) => void;

	// Player management events.
	playerJoined: (player: Player) => void;
	playerLeft: (playerId: string) => void;
	playerSwitchedTeam: (playerId: string, newTeamId: number) => void;
	playerReadyChanged: (playerId: string, isReady: boolean) => void;

	// Ready state events.
	allPlayersReady: () => void;
	notEnoughPlayers: () => void;

	// Game lifecycle events.
	gameStarted: (gameState: GameState) => void;
	gameEnded: (winnerTeam: Team, finalScores: Record<'team1' | 'team2', number>, isByBelot?: boolean) => void;

	roundStarted: (roundNumber: number, dealer: Player) => void;
	roundCompleted: (roundNumber: number, scores: { team1: number; team2: number }, winningTeam: Team, failedTeam?: Team) => void;

	// Timer events.
	timerUpdate: (timeLeft: number, timerFor: Player | null) => void;

	// Dealing phase events.
	initialCardsDealt: (playerCards: { playerId: string; cardCount: number }[]) => void;
	talonDealt: (playerTalon: { playerId: string; talon: Card[]; }[]) => void;

	// Bidding phase events.
	biddingStarted: (firstPlayer: Player) => void;
	bidMade: (playerId: string, call: CardColor | 'pass') => void;
	adutChosen: (adut: CardColor, playerId: string) => void;
	nextPlayerBid: (player: Player) => void;

	// Calling phase events.
	callingPhaseStarted: () => void;
	callMade: (playerId: string, cards: Card[], callingResult: CallingResult | null) => void;
	callingPhaseEnded: (winningCall: CallingsCall | null) => void;
	belotWin: (playerId: string, belotColor: CardColor) => void;

	// Playing phase events.
	playingPhaseStarted: () => void;
	cardPlayed: (playerId: string, card: Card) => void;
	nextPlayerMove: (player: Player) => void;
	trickCompleted: (trick: Trick, winnerId: string) => void;
	nextTrickStarted: (leadPlayer: Player) => void;
}



================================================
File: core/utils.ts
================================================
import { CallingResult, Callings, CallingsCall, Card, CardColor, CardColorLocal, cardColors, CardPoints, CardPointsAdut, CardType, CardTypeLocal, cardTypeOrder, cardTypes, PlayedCard } from './types';

export function mulberry32(seed: number): () => number {
	return function () {
		let t = seed += 0x6D2B79F5;
		t = Math.imul(t ^ (t >>> 15), t | 1);
		t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
		return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
	};
}

export function shuffleCards(deck: Card[], times: number = 1, rng?: () => number): Card[] {
	if (!Array.isArray(deck)) throw new Error('Deck must be an array of cards.');
	else if (times < 1) throw new Error('Times must be greater than 0.');

	const random = rng ?? mulberry32(Date.now());

	for (let t = 0; t < times; t++) {
		for (let i = deck.length - 1; i > 0; i--) {
			const j = Math.floor(random() * (i + 1));
			[deck[i], deck[j]] = [deck[j]!, deck[i]!];
		}
	}

	return deck;
}

export function getCardValue(card: Card, adut: CardColor) {
	if (card.color === adut) return CardPointsAdut[card.type];
	else return CardPoints[card.type];
}

export function getCardImageUrl(card: Card, size: 'large' | 'medium' | 'small' = 'medium', imageProvider: string): string {
	const localizedColor = cardColorLocalized(card.color);
	const localizedType = cardTypeLocalized(card.type);

	return `${imageProvider}/${size}/${localizedColor}/${localizedType}.webp`;
}

export function getCardColorImageUrl(color: CardColor, size: 'large' | 'medium' | 'small' = 'medium', imageProvider: string): string {
	const localizedColor = cardColorLocalized(color);
	return `${imageProvider}/${size}/colors/${localizedColor}.webp`;
}

export function createDeck(shuffle: number = 1): Card[] {
	const deck: Card[] = [];
	for (const color of cardColors) {
		for (const type of cardTypes) {
			deck.push({ color, type });
		}
	}

	return shuffleCards(deck, shuffle);
}

export function isConsecutiveSequence(cards: Card[]): boolean {
	for (let i = 0; i < cards.length - 1; i++) {
		const currIndex = cardTypeOrder.indexOf(cards[i]!.type);
		const nextIndex = cardTypeOrder.indexOf(cards[i + 1]!.type);
		if (nextIndex !== currIndex + 1) return false;
	}

	return true;
}

export function validateCalling(cards: Card[], adut: CardColor): CallingResult | null {
	let bestCall: CallingResult | null = null;

	const cardsByColor: Record<CardColor, Card[]> = { hearts: [], diamonds: [], clubs: [], spades: [] };
	const cardsByType: Record<CardType, Card[]> = {
		Ace: [], King: [], Queen: [], Jack: [], Ten: [], Nine: [], Eight: [], Seven: [],
	};

	for (const card of cards) {
		cardsByColor[card.color].push(card);
		cardsByType[card.type].push(card);
	}

	const tryUpdateBest = (call: CallingResult) => {
		if (!bestCall || call.type > bestCall.type) bestCall = call;
	};

	// 1. Check for Belot (8 cards of same color).
	for (const color of cardColors) {
		if (cards.length === 8 && cardsByColor[color].length === 8) {
			return { type: Callings.Belot };
		}
	}

	// 2. Check Bela: exactly 2 cards - King and Queen of adut.
	if (cards.length === 2 && cardsByColor[adut].some((c) => c.type === 'King') && cardsByColor[adut].some((c) => c.type === 'Queen')) {
		if (cards.every((c) => c.color === adut && (c.type === 'King' || c.type === 'Queen'))) {
			tryUpdateBest({ type: Callings.Bela });
		}
	}

	// 2. Check four of a kind.
	for (const type of ['Jack', 'Nine', 'Ace', 'King', 'Queen', 'Ten'] as CardType[]) {
		if (cards.length === 4 && cardsByType[type].length === 4) {
			switch (type) {
				case 'Jack': tryUpdateBest({ type: Callings.Jack4 }); break;
				case 'Nine': tryUpdateBest({ type: Callings.Nine4 }); break;
				case 'Ace': tryUpdateBest({ type: Callings.Ace4 }); break;
				case 'King': tryUpdateBest({ type: Callings.King4 }); break;
				case 'Queen': tryUpdateBest({ type: Callings.Queen4 }); break;
				case 'Ten': tryUpdateBest({ type: Callings.Ten4 }); break;
			}
		}
	}

	// 3. Check for sequences.
	if (cards.length >= 3) {
		const firstColor = cards[0]!.color;

		if (cards.every((c) => c.color === firstColor)) {
			const sortedCards = cards.slice().sort((a, b) => cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type));
			if (isConsecutiveSequence(sortedCards)) {
				const callKey = `Sequence${cards.length}` as keyof typeof Callings;

				if (Callings[callKey]) tryUpdateBest({ type: Callings[callKey] });
				else if (cards.length >= 5) tryUpdateBest({ type: Callings.Sequence5 });
			}
		}
	}

	return bestCall;
}

export function getHighestCall(calls: CallingsCall[]): CallingsCall | null {
	if (calls.length === 0) return null;

	return calls.reduce((highest, current) => {
		if (!highest) return current;

		const comparison = compareCallStrength(current, highest);
		return comparison > 0 ? current : highest;
	});
}

export function compareCallStrength(call1: CallingsCall, call2: CallingsCall): number {
	const getCallStrength = (call: Callings): number => {
		switch (call) {
			case Callings.Sequence3: return 1;
			case Callings.Sequence4: return 2;
			case Callings.Sequence5: return 3;
			case Callings.Sequence6: return 4;
			case Callings.Sequence7: return 5;
			case Callings.Bela: return 6;
			case Callings.Ace4: return 7;
			case Callings.King4: return 8;
			case Callings.Queen4: return 9;
			case Callings.Jack4: return 10;
			case Callings.Nine4: return 11;
			case Callings.Ten4: return 12;
			case Callings.Belot: return 13;
			default: return 0;
		}
	};

	const strength1 = getCallStrength(call1.call);
	const strength2 = getCallStrength(call2.call);

	if (strength1 !== strength2) {
		return strength1 - strength2;
	}

	if (call1.call >= Callings.Sequence3 && call1.call <= Callings.Sequence7) {
		const highestCard1 = getHighestCardInSequence(call1.cards);
		const highestCard2 = getHighestCardInSequence(call2.cards);

		return CardPoints[highestCard1.type] - CardPoints[highestCard2.type];
	}

	return 0;
}

export function getHighestCardInSequence(cards: Card[]): Card {
	return cards.reduce((highest, current) => {
		return CardPoints[current.type] > CardPoints[highest.type] ? current : highest;
	});
}

export function canPlayCard(card: Card, currentTrick: PlayedCard[], adut: CardColor, playerCards: Card[]): boolean {
	if (currentTrick.length === 0) return true;

	const leadingSuit = currentTrick[0]!.color;
	const hasLeadingSuit = playerCards.some((c) => c.color === leadingSuit);

	// If player has leading suit, must follow suit.
	if (hasLeadingSuit) {
		if (card.color !== leadingSuit) return false;

		// If leading suit is trump, must play higher trump if possible.
		if (leadingSuit === adut) {
			const mustBeatCard = getHighestTrumpInTrick(currentTrick, adut);
			if (mustBeatCard && canBeatCard(card, mustBeatCard, adut)) {
				const hasHigherTrump = playerCards.some((c) => c.color === adut && canBeatCard(c, mustBeatCard, adut));
				return !hasHigherTrump || canBeatCard(card, mustBeatCard, adut);
			}
		} else {
			// Non-trump suit - must play higher if possible (unless trump was played).
			const trumpPlayed = currentTrick.some((c) => c.color === adut);
			if (!trumpPlayed) {
				const highestCard = getHighestNonTrumpInTrick(currentTrick, adut);
				if (highestCard && canBeatCard(card, highestCard, adut)) {
					const hasHigherCard = playerCards.some((c) => c.color === leadingSuit && canBeatCard(c, highestCard, adut));
					return !hasHigherCard || canBeatCard(card, highestCard, adut);
				}
			}
		}

		return true;
	}

	// No leading suit - must play trump if available.
	const hasTrump = playerCards.some((c) => c.color === adut);
	if (hasTrump) {
		if (card.color !== adut) return false;

		// Must beat highest trump if possible.
		const highestTrump = getHighestTrumpInTrick(currentTrick, adut);
		if (highestTrump) {
			const hasHigherTrump = playerCards.some((c) => c.color === adut && canBeatCard(c, highestTrump, adut));
			return !hasHigherTrump || canBeatCard(card, highestTrump, adut);
		}
	}

	// No leading suit, no trump - can play any card.
	return true;
}

export function findLegalCard(currentTrick: PlayedCard[], adut: CardColor, playerCards: Card[]): Card | null {
	return playerCards.find((card) => canPlayCard(card, currentTrick, adut, playerCards)) || null;
}

export function canBeatCard(card: Card, targetCard: Card, adut: CardColor): boolean {
	if (card.color === adut && targetCard.color === adut) return CardPointsAdut[card.type] > CardPointsAdut[targetCard.type];

	if (card.color === adut && targetCard.color !== adut) return true;
	if (card.color !== adut && targetCard.color === adut) return false;

	if (card.color === targetCard.color) {
		return CardPoints[card.type] > CardPoints[targetCard.type];
	}

	return false;
}

export function getHighestTrumpInTrick(trick: PlayedCard[], adut: CardColor): Card | null {
	const trumpCards = trick.filter((c) => c.color === adut);
	if (trumpCards.length === 0) return null;

	return trumpCards.reduce((highest, current) => CardPointsAdut[current.type] > CardPointsAdut[highest.type] ? current : highest);
}

export function getHighestNonTrumpInTrick(trick: PlayedCard[], adut: CardColor): Card | null {
	const nonTrumpCards = trick.filter((c) => c.color !== adut);
	if (nonTrumpCards.length === 0) return null;

	return nonTrumpCards.reduce((highest, current) => CardPoints[current.type] > CardPoints[highest.type] ? current : highest);
}

export function cardColorLocalized(color: CardColor): CardColorLocal {
	switch (color) {
		case 'hearts': return 'herc';
		case 'diamonds': return 'karo';
		case 'clubs': return 'tref';
		case 'spades': return 'pik';
	}
}

export function cardTypeLocalized(type: CardType): CardTypeLocal {
	switch (type) {
		case 'Ace': return 'As';
		case 'King': return 'Kralj';
		case 'Queen': return 'Baba';
		case 'Jack': return 'Decko';
		case 'Ten': return 'Deset';
		case 'Nine': return 'Devet';
		case 'Eight': return 'Osam';
		case 'Seven': return 'Sedam';
	}
}

export function normalizeLocalColor(color: CardColorLocal): CardColor {
	switch (color) {
		case 'herc': return 'hearts';
		case 'karo': return 'diamonds';
		case 'tref': return 'clubs';
		case 'pik': return 'spades';
	}
}

export function normalizeLocalType(type: CardTypeLocal): CardType {
	switch (type) {
		case 'As': return 'Ace';
		case 'Kralj': return 'King';
		case 'Baba': return 'Queen';
		case 'Decko': return 'Jack';
		case 'Deset': return 'Ten';
		case 'Devet': return 'Nine';
		case 'Osam': return 'Eight';
		case 'Sedam': return 'Seven';
	}
}


